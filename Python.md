### 乐观锁和悲观锁

```
悲观锁: 正如其名，具有强烈的独占和排他特性。它指的是对数据被外界 （包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。

乐观锁: 乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。

乐观锁: 大多是基于数据版本记录机制实现,(数据版本:为数据表增加一个 version 的字段),读出数据的时候,将次版本一起读出来,更新的时候对此版本加1 , 如果读出的版本 比 数据库表原来版本大 就更新成功,否则认为是过期数据.

悲观锁: 具有强烈的独占性和排他性, 就是修改数据的时候 对外保持锁定状态
```



### PEP8规范

- 每一级缩进使用四个空格
- 所有行最大字符数为79
- 顶层函数和类的定义, 前后用两个空行隔开
- 类里面的方法用一个空行隔开

- import os  (不推荐 import os, sys)



### 可变数据类型和不可变数据类型

- 可变:    列表, 字典, 集合
- 不可变:    字符串,整数,布尔值,元祖

### python设计哲学及版本

- 优雅 明确 简单 ... 
- 91年发布python第一个python版本
- 00年 第一个稳定的 python2.7版本
- 08年 python3发布
- 20年 不在维护python2

### Python3特性和变化 

##### 特性

- 动态解释性语言 (解释型语言)
- 开发维护成本低 (代码简洁,易维护)
- 丰富的生态圈 (第三方模块多)

##### 变化

- 一、 print 从语句变为函数

  原:     print   1, 2+3

  改为: print ( 1, 2+3 )

- 二 range 和 xrange

  返回迭代器(可迭代对象)

- 默认的源文件编码从ASCII变为UTF-8

- int 和 long 转为 int (效果和long一样) 2**32

- 原: **字符串以 8-bit 字符串**存储

  改为: **字符串以 16-bit Unicode 字符串**存储

### GIL

- 即全局解释器所（[global interpreter lock](https://www.baidu.com/link?url=wcyORPNvihJlWYZsd97z3F3g6xZfs09N64Jc56POq3P7r3h5vIxVFcjGiZjosC6g3jhmBh13DS36rKld5eBfWq&wd=&eqid=aa7605a200005349000000025aa0f4fb)），每个线程在执行时候都需要先获取GIL，保证同一时刻只有一个线程可以执行代码，即同一时刻只有一个线程使用CPU，也就是说多线程并不是真正意义上的同时执行
- 一个进程同一时刻只能有一个线程在运行
- I/O输入/输出(Input/Output)

- Python的多线程只对IO密集型计算产生正面效果，而当其中至少有一个CPU密集型任务时，多线程效率将急剧下降。
- **问题1: 什么时候会释放Gil锁**

- 答 :  
  1 遇到像 i/o操作这种 会有时间空闲情况 造成cpu闲置的情况会释放Gil
  2 会有一个专门ticks进行计数 一旦ticks数值达到100 这个时候释放Gil锁 线程之间开始竞争Gil锁(说明:

###  问题2: 互斥锁和Gil锁的关系

Gil锁  : 保证同一时刻只有一个线程能使用到cpu
互斥锁 : 多线程时,保证修改共享数据时有序的修改,不会产生数据修改混乱  

### 如何避免GIL锁带来的消极影响?

- 使用多进程
- 换用其他解释器

### python是如何进行内存管理的

- 对象引用计数 (sys.getrefcount("变量")  查看变量引用次数)
- 垃圾回收 (引用计数为0的回收)
- 小数据池 (bool,int,str)  (-5,256) (字符串长度0或1)

### 什么是socket

```
2个程序通过一个双向通信连接实现数据交互,其中的一端就是一个socket.
socket本身是编程接口(API) 是对 TCP/IP 的封装.
```



### python进程

- **进程就是一个程序在一个数据集上的一次动态执行过程**

- 是系统进行资源分配和调度的基本单位

- 进程是正在运行的程序的实例

- 进程: 运行一个程序的执行过程

- 一段程序的执行过程

- 适用场景:CPU密集型任务

- 缺陷:
  ​    创建和切换代价高

  ​    进程间通信效率相对低
  ​    资源消耗大

#### 线程

   是[操作系统](https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)能够进行运算[调度](https://baike.baidu.com/item/%E8%B0%83%E5%BA%A6)的最小单位。

​    内核线程、用户线程

​    资源共享

- 适用场景: 纯io密集型任务
- 优势:
  ​    资源共享
  ​    线程间通信效率高
  ​    切换代价较低
- 缺陷: 
  ​    GIL锁(同一进程同一时间只能有一个线程使用CPU)

#### 协程

​    协程，又称微线程，是一种用户态的轻量级线程。一个单线程里面实现

​    适用场景: 

​        大量不需要CPU的操作时（IO），适用于协程。

​    优势:

​         省去大量线程切换开销

​         单线程运行，无需加锁, 解决了多线程加锁造成的相关问题

### LEGB

```
LEGB含义解释：
L-Local(function)；函数内的名字空间
E-Enclosing function locals；外部嵌套函数的名字空间(例如closure)
G-Global(module)；函数定义所在模块（文件）的名字空间
B-Builtin(Python)；Python内置模块的名字空间

LEGB规定了查找一个名称的顺序为：local-->enclosing function locals-->global-->builtin
```



### 关系型数据库和非关系型数据库

```
关系型数据库: MySQL, Oracle, MariaDB, SQL Server
非关系型数据库: Redis, MongoDB, memcached

关系型数据库:
	优点
		使用表结构, 支持sql语言;
		支持连表查询
	缺点
		读写性能较差, 海量数据时瓶颈出现;
		灵活度不高;
		高并发情况下硬盘IO出现瓶颈

非关系型数据库
	格式灵活
	高扩展性
	速度快
	成本低

```



### MySQL备份命令

``` 
mysqldump -h 192.168.1.100 -p 3306 -uroot -ppassword --database cmdb > /data/backup/cmdb.sql
 
```



### MySQl存储引擎

```
InnoDB：支持事务处理，支持外键，支持崩溃修复能力和并发控制。 对空间使用程度较高，要求实现并发控制（比如售票） 频繁的更新、删除

MyISAM：插入数据快，空间和内存使用比较低。 用于插入新记录和读出记录, 不支持事务, 不支持外键

MEMORY：所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，

```

### MySQL索引类型,机制

```
b+tree树,rtree

BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中。如二叉树一样，每次查询都是从树的入口root开始，依次遍历node，获取leaf。

```

### MySQL适用场景

```
1、Web网站系统

2、日志记录系统

3、数据仓库系统
```



### Mysql5.7新变化特性-----Mysql8.0

```
Mysql 5.7新变化特性: 
开始支持json串格式字段
性能提升: 自动检测只读事务,支持并行复制

Mysql 8.0变化特性:
mysql 8 开始支持文档存储. (文档是一堆键值对的集合,表现为JSON结构)
性能大幅提升, 速度比5.7快两倍
默认字符按编码改为了utf8mb4 (支持表情)
```



### 事务四大特性

```
ACID
1. 原子性 (要么成功,要么都失败回滚)
2. 一致性 (数据库总数从一个一致性的状态转移到另一个一致性的状态)
3. 隔离性 (一个事务所做的修改在最终提交以前，对其他事务是不可见的)
4. 持久性 (一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。)


```



### 事务隔离级别

```
并发下事务会产生的问题:

脏读:
	一个事务读取到了另一个事务未提交的数据操作结果. (这是相当危险的,因为很可能所有的操作都被回滚.)

不可重复读:
	一个事务对 "同一行数据" 重复读取两次,但是却得到了不同结果
	
幻读:
	在一个事务里面的操作中发现了未被操作的数据(另一个事务插入或删除了其他数据)


四个隔离级别:

读未提交(Read Uncommitted):
	能读取到没有被提交的数据, (无法解决 脏读,不可重复读,幻读)

读已提交(Read Commited):
	能读取到已经提交的数据,防止了脏读 (无法解决,不可重复读,幻读)

可重复读(Repeatable Read):
	重复读取,在数据读出来之后加锁,确保了2次读取同一数据相同(无法解决幻读)
	
串行化(Serializable):
	不管多少个事务,诶个运行完一个事务后再执行其他事务(解决了所有的问题,但是效率低下)
```



### Mysql ---MVCC

```
Multi-Version Concurrency Control 多版本并发控制，MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问；在编程语言中实现事务内存。
```



###  Gap Lock

```
行锁（Record Lock）:锁直接加在索引记录上面，锁住的是key。
间隙锁（Gap Lock）:锁定索引记录间隙，确保索引记录的间隙不变。间隙锁是针对事务隔离级别为可重复读或以上级别而已的。
在索引记录之间的间隙中加锁，或者是在某一条索引记录之前或者之后加锁，并不包括该索引记录本身。
```



### Redis适用场景

```
1、计数器相关问题
2、延时操作
3、限时业务的运用
```



### Redis数据类型

```
string  字符串
list    列表
hash    键值对
集合     set
有序集合  zset(sorted set)
```



### Redis存储机制

```
Redis存储机制分成两种Snapshot和AOF。无论是那种机制,Redis都是将数据存储在内存中。

定时快照方式(snapshot)[RDB方式]
该方式实际是在Redis内部执行一个定时任务，根据redis.conf中配置的save的时间间隔去检查当前数据改变次数和时间是否满足配置，如果满足则从父进程fork(copy-on-write机制)出一个子进程，通过该子进程遍历内存来转换成rdb文件；

基于语句追加文件的方式(aof)
类似mysql的binlog方式，每个数据发生改变都会追加至一个log文件中；
```



### ZSet存储机制

```
内部使用跳跃表实现
```



### Redis持久化方式

```
Redis存储机制分成两种Snapshot和AOF。无论是那种机制,Redis都是将数据存储在内存中。

定时快照方式(snapshot)[RDB方式]
该方式实际是在Redis内部执行一个定时任务，根据redis.conf中配置的save的时间间隔去检查当前数据改变次数和时间是否满足配置，如果满足则从父进程fork(copy-on-write机制)出一个子进程，通过该子进程遍历内存来转换成rdb文件；

基于语句追加文件的方式(aof)
类似mysql的binlog方式，每个数据发生改变都会追加至一个log文件中；
```



### MongoDB和MySQL差异

```
MongoDB: 非关系型  不支持连表  仅支持单文档事务操作,弱一致性
MySQL:   关系型    支持连表   支持事务操作
```



### MongoDB使用场景

```
网站数据：适合实时的插入，更新与查询，并具备网站实时数据存储所需的复制及高度伸缩性。
缓存：由于性能很高，也适合作为信息基础设施的缓存层。在系统重启之后，搭建的持久化缓存可以避免下层的数据源过载。
大尺寸、低价值的数据：使用传统的关系数据库存储一些数据时可能会比较贵，在此之前，很多程序员往往会选择传统的文件进行存储。
高伸缩性的场景：非常适合由数十或者数百台服务器组成的数据库。
用于对象及JSON数据的存储：MongoDB的BSON数据格式非常适合文档格式化的存储及查询。

```



### 粘包

```
数据太小不够缓冲区大;
接收方没及时接收缓冲区的包,造成多个包接收(客户端发送一段数据,服务端只接收了一小段)

解决方案一 
先发送数据的总大小过去


解决方案二
每次发送 1024 大小数据

解决方案三
使用第三方工具 struck打包大小成4个字节+内容, 接收方先接收4个字节的长度 然后再去决定接收多少的内容
```



### TCP和UDP的区别

```
TCP
面向流的,数据可靠,面向连接的协议

UDP
面向包的,不会产生粘包,数据不可靠,无连接的服务

```



### 并发和并行

```
并发: 伪并行,既看起来是同时运行. 单个CPU+多道技术就可以实现
并行: 同时运行, 多个CPU同时运行 
```



### HTTP和HTTPS的区别

```
http: 超文本传输协议, 简单,明文,无状态

https: 安全超文本传输协议, https由http+ssl协议构建的可进行加密传输,身份认证的网络协议
主要就是 http安全 https不安全
```

![UDP](C:\Users\Administrator\Desktop\python\网络编程\UDP.png)

![基于tcp网络通行流程](C:\Users\Administrator\Desktop\python\网络编程\基于tcp网络通行流程.png)

### GET 和 POST 的区别

```
GET: 求的URL传参有长度限制，请求参数放在URL里面, 一般用于查看数据

POST: 而POST请求没有长度限制,参数放在body里面, 一般用于提交数据
```



## web相关

### TCP握手挥手及原理

![三次握手](C:\Users\Administrator\Desktop\python\网络编程\三次握手.png)



![三次握手_四次挥手](C:\Users\Administrator\Desktop\python\网络编程\三次握手_四次挥手.png)

![四次挥手](C:\Users\Administrator\Desktop\python\网络编程\四次挥手.png)

### TCP连接状态

```
LISTEN：侦听来自远方的TCP端口的连接请求

SYN-SENT：再发送连接请求后等待匹配的连接请求（客户端）

SYN-RECEIVED：再收到和发送一个连接请求后等待对方对连接请求的确认（服务器）

ESTABLISHED：代表一个打开的连接

FIN-WAIT-1：等待远程TCP连接中断请求，或先前的连接中断请求的确认

FIN-WAIT-2：从远程TCP等待连接中断请求

CLOSE-WAIT：等待从本地用户发来的连接中断请求

CLOSING：等待远程TCP对连接中断的确认

LAST-ACK：等待原来的发向远程TCP的连接中断请求的确认

TIME-WAIT：等待足够的时间以确保远程TCP接收到连接中断请求的确认

CLOSED：没有任何连接状态

```



### 一次完成的HTTP请求详细流程

```
域名解析 –> 发起TCP的3次握手 –> 建立TCP连接后发起http请求 –> 服务器响应http请求，浏览器得到html代码 –> 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） –> 浏览器对页面进行渲染呈现给用户

整个网络通行流程
1 打开浏览器 输入京东官网 ,
2 请求发给 交换机 ,路由器,DNS服务器 ,(通过DNS服务器找到京东IP地址)
3 DNS服务解析域名找到京东IP地址后,路由器 通过路由协议 找到路由转发的最优路径,将你的请求发给京东的路由器
4 京东路由器 将请求发给京东服务器上
5 京东服务器收到你的请求之后 ,原路返回你 他网站的信息
6 (当你打开浏览器的时候,电脑给他起个编号 端口) 你收到京东发来消息的时候 ,端口号找到你的浏览器,你的浏览器收到
京东发啦的网站信息,呈现出来
```



### Django具体知识点

```
Django的MTV模型:
M 代表模型（Model）： 负责业务对象和数据库的关系映射(ORM)。
T 代表模板 (Template)：负责如何把页面展示给用户(html)。
V 代表视图（View）：   负责业务逻辑，并在适当时候调用Model和Template。

django的设计哲学是简单,快速,强调代码复用,大而全是它的特性,而flask相对而言小而精,
tornado和sanic是异步框架,性能都非常卓越,
如果希望开发过程中框架有丰富的第三方插件, 推荐使用django和flask

```



### Flask具体知识点(如g对象)

````

````



### 同步和异步

```
1. 同步，就是调用一个功能，该功能没有结束前，一直等结果。
2. 异步，就是调用一个功能，不需要知道该功能结果，该功能有结果后通知（回调通知）
```

![同步和异步](C:\Users\Administrator\Desktop\python\网络编程\同步和异步.jpg)

![阻塞和非阻塞](C:\Users\Administrator\Desktop\python\网络编程\阻塞和非阻塞.png)



### 阻塞非阻塞

```
3. 阻塞，就是调用（函数），（函数）没有接收完数据或者没有得到结果之前，不会返回。
4. 非阻塞，就是调用（函数），（函数）立即返回，通过select通知调用者。
```



### IO多路复用(input/output)

```
其实多路复用的实现有多种方式：select、poll、epoll
```



### Nginx作用及使用场景

```
2018年03月20日，nginx-1.13.10主线版本发布
Nginx是一个高性能的HTTP和反向代理web服务器
支持高并发,资源消耗少
可以做反向代理,负载均衡
```



## Linux相关

### shell命令(查看端口,负载,内存)

```
mkdir 创建目录
mkdir -p liulaoshi/chenwen/liujie/xiaowei  # 递归创建目录
mkdir -p {qihang,chenwen,yanglan,xiaowei}  # 创建多个目录

crontab -e #  编辑计划任务
kill 
tar -xf xxx.tar    ## -xf      解压.tar
tar -zxvf xxx.tar.gz  ## -zxvf 解压.gz
sudo
touch liulaoshi.py qihang.py yanglan.py xiaowei.py # 创建多个文件
yum 
vim 
cat
find / -name python # 查找
rm 
which pwd # 查看某个系统命令是否存在 打印绝对路径

scp -r 发送方 接收方
    本地     另一条服务器  
scp xxx.py root@192.168.12.77:/opt/ 
top
ps -ef # 进程
df -h # 查看系统磁盘空间
netstat -tunlp # 产看开发的端口
kill 杀进程
```



### 正则

```
\w [A-Za-z0-9_]
\d [0-9]
\s 空白符
.*? 非贪婪
.* 贪婪匹配
match 从开头开始匹配
search 匹配第一个合适的
```



### SYN FLOOD (拒绝服务攻击)

```
SYN Flood是一种广为人知的DoS（拒绝服务攻击）是DDoS（分布式拒绝服务攻击）的方式之一，这是一种利用TCP协议缺陷，发送大量伪造的TCP连接请求，从而使得被攻击方资源耗尽（CPU满负荷或内存不足）的攻击方式。
```



### CentOS和Ubuntu差异

```
Ubuntu 图形化界面
CentOS 没有图形化界面
```



### 正向代理和反向代理

```
正向代理，架设在客户机和目标主机之间； 
反向代理，架设在服务器端；

正向代理，代理客户端，服务端不知道实际发起请求的客户端； 
反向代理，代理服务端，客户端不知道实际提供服务的服务端； 

正向代理的应用:
1 访问原来无法访问的资源
2 加快访问速度
3 对外隐藏用户信息

反向代理的应用:
1 保护内网安全
2 负载均衡
3 减少服务器压力
```

### 负载均衡

```
可以减轻服务器的压力
轮询    　　　　按时间顺序逐一分配到不同的后端服务器(默认)

Nginx要实现负载均衡需要用到proxy_pass代理模块配置
Nginx负载均衡是将客户端请求代理转发至一组upstream虚拟服务池
Nginx可以配置代理多台服务器，当一台服务器宕机之后，仍能保持系统可用。
```



### 常用的WEB框架有哪些

```
django 重量级别的框架, 功能非常多,内置模块非常多, 600-2000req/s
flask 轻量级的框架,从第三方引入过来的 2500req/s
tornado   异步非阻塞  支持多用户并发访问3000req/s
sanic  是python3.5之后的一个框架,  20000req/s

```



### 数据库的六大约束

```
主键约束 : primary key;
 外键约束 : foreign key;
 非空约束 : not null;
 唯一约束 : unique;
 检查约束 : check;
 默认约束 : default;
```



### uWSGI

```
uWSGI是一个Web服务器, 它实现了WSGI协议, uwsgi,http等 协议他要做的就是把 HTTP 协议转化成语言支持的网络协议。比如把 HTTP 协议转化成 WSGI 协议，让 Python 可以直接使用。 

WSGI是一种通信协议, 是web服务器和web应用之间一种简单而同用的网关接口,
uwsgi是一种线路协议而不是通信协议,常用与uWSGI服务器和其他网络服务器的数据通信
而uWSGI是实现了uwsgi和WSGI两种协议的Web服务器

```



## RPC

```
远程过程调用(RPC)是一种协议, 程序可使用这种协议向网络中的另一台计算机上的程序请求服务
```



## RESTful API

```
1.协议
	API与用户的通信协议，总是使用HTTPs协议(SSL/TLS)。
	
2.域名
	应该尽量将API部署在专用域名之下

3.版本(Versioning)
	将API的版本号放入URL.

4.路径
	路径又称"终点",表示API的具体网址.

5.HTTP动词
	常用的HTTP动词有五个
	GET: 查看一条或多条数据
	POST: 提交一条数据
	PUT: 更新一条数据
	DELETE: 删除一条数据
	
	PATCH: 更新数据
	
```



## RabbitMQ

```
优点:
	性能好,高并发,单机QPS在万数量级
	可靠性高,有消息确认机制和持久化机制;
	可定制路由;
	社区活跃,管理界面丰富;
缺陷:
	不利于二次开发和维护;
	接口和协议较复杂,学习成本较高;

RabbitMQ注意事项:
	RabbitMQ的消息应当尽可能的小,并且只用来处理实时且要高可靠性的消息
	消费者和生产者的能力尽量对等,否则消息堆积会严重影响RabbitMQ的性能
	集群部署,使用热备,保证消息的可靠性
	
```



## Kafka

```
优点:
	1. 客户端语言丰富
	2. 性能极佳,单机QPS百万级别
	3. 分布式架构,拥有高可用性和可靠性,理论消息存储无上限
	4. 消费者采用Pull方式获取信息,消息有序,通过控制能够保证所有消息被消费且仅被消费一次
	5. 有优秀的第三方Kafka Web管理界面 Kafka-Manger
	6. 在日志领域比较成熟,被多家公司和多个开源项目使用
	7. 支持批量操作
缺点:
	1. 目前支持的功能没有RabbitMQ丰富
	2. 消息传递只支持pull模式,不支持push
	3. 一台代理宕机后, 消息会发生乱序;

Kafka注意事项:
	1. 应答有一个非常好的运维监控系统,不单单要监控Kafka本身,还要监控Zookeeper
	2. 对消息顺序不依赖, 且不是那么实时的系统
	3. 对消息丢失并不那么敏感的系统
```

